package com.magiccontrol.recognizer

import android.content.Context
import android.content.pm.PackageManager
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.os.Process
import android.util.Log
import androidx.core.content.ContextCompat
import com.magiccontrol.utils.PreferencesManager
import kotlin.random.Random

class WakeWordDetector(private val context: Context) {

    private var audioRecord: AudioRecord? = null
    private var isListening = false
    private val sampleRate = 16000
    private val bufferSize = 1024
    private val TAG = "WakeWordDetector"
    private var consecutiveVoiceDetections = 0
    private val voiceDetectionThreshold = 5

    // D√©tection manuelle - d√©clenche au bout de 3 secondes
    private var detectionTimer = 0
    private val detectionTimeThreshold = 60 // 60 * 50ms = 3 secondes

    var onWakeWordDetected: (() -> Unit)? = null

    private fun hasMicrophonePermission(): Boolean {
        val hasPerm = ContextCompat.checkSelfPermission(
            context,
            android.Manifest.permission.RECORD_AUDIO
        ) == PackageManager.PERMISSION_GRANTED
        Log.d(TAG, "üîß Permission micro: $hasPerm")
        return hasPerm
    }

    fun startListening(): Boolean {
        Log.d(TAG, "üéß DEMANDE D√âMARRAGE √âCOUTE")
        
        if (isListening) {
            Log.d(TAG, "‚ö†Ô∏è D√©j√† en √©coute")
            return true
        }

        if (!hasMicrophonePermission()) {
            Log.e(TAG, "‚ùå Permission micro refus√©e")
            return false
        }

        try {
            Log.d(TAG, "üîß Configuration AudioRecord...")
            val minBufferSize = AudioRecord.getMinBufferSize(
                sampleRate,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT
            )
            Log.d(TAG, "üîß Taille buffer min: $minBufferSize")

            if (minBufferSize == AudioRecord.ERROR || minBufferSize == AudioRecord.ERROR_BAD_VALUE) {
                Log.e(TAG, "‚ùå Taille buffer invalide")
                return false
            }

            audioRecord = AudioRecord(
                MediaRecorder.AudioSource.VOICE_RECOGNITION,
                sampleRate,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT,
                minBufferSize.coerceAtLeast(bufferSize)
            )

            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {
                Log.e(TAG, "‚ùå AudioRecord non initialis√©")
                audioRecord?.release()
                audioRecord = null
                return false
            }

            audioRecord?.startRecording()
            isListening = true
            detectionTimer = 0

            Log.d(TAG, "‚úÖ AudioRecord initialis√© et d√©marr√©")

            Thread {
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
                val buffer = ByteArray(bufferSize)
                Log.d(TAG, "üéß Thread √©coute d√©marr√©")

                while (isListening) {
                    try {
                        val bytesRead = audioRecord?.read(buffer, 0, bufferSize) ?: 0
                        if (bytesRead > 0) {
                            // ‚úÖ MESURE NIVEAU AUDIO - AJOUT
                            val audioLevel = calculateAudioLevel(buffer, bytesRead)
                            val hasVoice = audioLevel > 1000
                            Log.d(TAG, "üé§ Audio: ${bytesRead}bytes, Niveau: $audioLevel, Voix: $hasVoice")
                            
                            if (hasVoice) {
                                consecutiveVoiceDetections++
                                Log.d(TAG, "üéØ Voix d√©tect√©e ($consecutiveVoiceDetections/$voiceDetectionThreshold)")
                                
                                if (consecutiveVoiceDetections >= voiceDetectionThreshold) {
                                    Log.d(TAG, "‚úÖ D√âTECTION VOIX CONFIRM√âE")
                                    consecutiveVoiceDetections = 0
                                    onWakeWordDetected?.invoke()
                                    break
                                }
                            } else {
                                consecutiveVoiceDetections = 0
                            }
                            // ‚úÖ D√âTECTION FORC√âE - Se d√©clenche apr√®s 3 secondes
                            detectionTimer++
                            Log.d(TAG, "üéß Audio captur√© ($bytesRead bytes) - Timer: $detectionTimer/$detectionTimeThreshold")
                            
                            if (detectionTimer >= detectionTimeThreshold) {
                                Log.d(TAG, "‚úÖ D√âTECTION FORC√âE APR√àS 3 SECONDES")
                                detectionTimer = 0
                                onWakeWordDetected?.invoke()
                                break
                            }
                        }
                        Thread.sleep(50)
                    } catch (e: Exception) {
                        Log.e(TAG, "‚ùå Erreur lecture audio", e)
                        break
                    }
                }
                Log.d(TAG, "üéß Thread √©coute arr√™t√©")
            }.start()

            Log.d(TAG, "‚úÖ D√©tection d√©marr√©e avec succ√®s")
            return true

        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Erreur d√©marrage √©coute: ${e.message}")
            stopListening()
            return false
        }
    }

    fun stopListening() {
        Log.d(TAG, "üîß Arr√™t √©coute demand√©")
        isListening = false
        detectionTimer = 0
        try {
            audioRecord?.stop()
            audioRecord?.release()
            Log.d(TAG, "üîß AudioRecord lib√©r√©")
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Erreur arr√™t √©coute: ${e.message}")
        }
        audioRecord = null
    }

    fun isListening(): Boolean = isListening

    private fun calculateAudioLevel(buffer: ByteArray, bytesRead: Int): Int {
        var sum = 0
        for (i in 0 until bytesRead.coerceAtMost(100)) {
            sum += Math.abs(buffer[i].toInt())
        }
        return sum / bytesRead.coerceAtLeast(1)
    }
}
