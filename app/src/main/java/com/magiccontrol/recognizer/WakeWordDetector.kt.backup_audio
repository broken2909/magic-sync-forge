package com.magiccontrol.recognizer

import android.content.Context
import android.content.pm.PackageManager
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.os.Process
import android.util.Log
import androidx.core.content.ContextCompat
import com.magiccontrol.utils.PreferencesManager
import kotlin.random.Random

class WakeWordDetector(private val context: Context) {

    private var audioRecord: AudioRecord? = null
    private var isListening = false
    private val sampleRate = 16000
    private val bufferSize = 1024
    private val TAG = "WakeWordDetector"

    // DÃ©tection manuelle - dÃ©clenche au bout de 3 secondes
    private var detectionTimer = 0
    private val detectionTimeThreshold = 60 // 60 * 50ms = 3 secondes

    var onWakeWordDetected: (() -> Unit)? = null

    private fun hasMicrophonePermission(): Boolean {
        val hasPerm = ContextCompat.checkSelfPermission(
            context,
            android.Manifest.permission.RECORD_AUDIO
        ) == PackageManager.PERMISSION_GRANTED
        Log.d(TAG, "ğŸ”§ Permission micro: $hasPerm")
        return hasPerm
    }

    fun startListening(): Boolean {
        Log.d(TAG, "ğŸ§ DEMANDE DÃ‰MARRAGE Ã‰COUTE")
        
        if (isListening) {
            Log.d(TAG, "âš ï¸ DÃ©jÃ  en Ã©coute")
            return true
        }

        if (!hasMicrophonePermission()) {
            Log.e(TAG, "âŒ Permission micro refusÃ©e")
            return false
        }

        try {
            Log.d(TAG, "ğŸ”§ Configuration AudioRecord...")
            val minBufferSize = AudioRecord.getMinBufferSize(
                sampleRate,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT
            )
            Log.d(TAG, "ğŸ”§ Taille buffer min: $minBufferSize")

            if (minBufferSize == AudioRecord.ERROR || minBufferSize == AudioRecord.ERROR_BAD_VALUE) {
                Log.e(TAG, "âŒ Taille buffer invalide")
                return false
            }

            audioRecord = AudioRecord(
                MediaRecorder.AudioSource.VOICE_RECOGNITION,
                sampleRate,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT,
                minBufferSize.coerceAtLeast(bufferSize)
            )

            if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {
                Log.e(TAG, "âŒ AudioRecord non initialisÃ©")
                audioRecord?.release()
                audioRecord = null
                return false
            }

            audioRecord?.startRecording()
            isListening = true
            detectionTimer = 0

            Log.d(TAG, "âœ… AudioRecord initialisÃ© et dÃ©marrÃ©")

            Thread {
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
                val buffer = ByteArray(bufferSize)
                Log.d(TAG, "ğŸ§ Thread Ã©coute dÃ©marrÃ©")

                while (isListening) {
                    try {
                        val bytesRead = audioRecord?.read(buffer, 0, bufferSize) ?: 0
                        if (bytesRead > 0) {
                            // âœ… DÃ‰TECTION FORCÃ‰E - Se dÃ©clenche aprÃ¨s 3 secondes
                            detectionTimer++
                            Log.d(TAG, "ğŸ§ Audio capturÃ© ($bytesRead bytes) - Timer: $detectionTimer/$detectionTimeThreshold")
                            
                            if (detectionTimer >= detectionTimeThreshold) {
                                Log.d(TAG, "âœ… DÃ‰TECTION FORCÃ‰E APRÃˆS 3 SECONDES")
                                detectionTimer = 0
                                onWakeWordDetected?.invoke()
                                break
                            }
                        }
                        Thread.sleep(50)
                    } catch (e: Exception) {
                        Log.e(TAG, "âŒ Erreur lecture audio", e)
                        break
                    }
                }
                Log.d(TAG, "ğŸ§ Thread Ã©coute arrÃªtÃ©")
            }.start()

            Log.d(TAG, "âœ… DÃ©tection dÃ©marrÃ©e avec succÃ¨s")
            return true

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Erreur dÃ©marrage Ã©coute: ${e.message}")
            stopListening()
            return false
        }
    }

    fun stopListening() {
        Log.d(TAG, "ğŸ”§ ArrÃªt Ã©coute demandÃ©")
        isListening = false
        detectionTimer = 0
        try {
            audioRecord?.stop()
            audioRecord?.release()
            Log.d(TAG, "ğŸ”§ AudioRecord libÃ©rÃ©")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Erreur arrÃªt Ã©coute: ${e.message}")
        }
        audioRecord = null
    }

    fun isListening(): Boolean = isListening
}
